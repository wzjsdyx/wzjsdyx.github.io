---
title: cache_controller设计（1）-理论基础
date: 2024-02-19 23:27:52
categories:
- cache设计
tags:
- cache基础知识
---

# 存储层次

由于物理实现上的差异，`CPU的速度和内存的速度差距越来越大`。例如DDR3内存的访问延时约为50ns，高端处理器的时钟周期都在1ns以下。

处理器和内存再速度上的差距形成了`存储层次`：

- 离处理器越近的地方，存储器的访问速度越快（使用存储密度小的电路结构，牺牲存储容量换取更快的访问速度）
- 离处理器越远的地方，存储器的访问速度越慢（使用存储密度大的电路结构，牺牲访问速度换取更快的存储容量）

{% asset_img 存储层次.png %}

<center><u>存储层次</u></center>

# cache在流水线中的位置

`cache是微体系结构的概念，没有独立的编制空间，对程序来说是透明的`。
cache在流水线中的位置：
{% asset_img cacher在流水线中的位置.png %}

<center><u>cacher在流水线中的位置</u></center>

当处理器访问cache时，首先会进行索引，找到对应的cache单元；然后会对tag进行对比：

- 命中，则直接对cache的内容进行访问
- 未命中，指令会阻塞在取指阶段或者访存阶段，然后通过cache失效逻辑处理后才能继续执行

# cache需要保存的内容

cache中的存储的内存数据是不断变化的（不同时刻可能存储不同的内存单元内容），因此cache需要保存如下内容：

- 数据
- 数据对应的地址（称为cache标签，tag，让流水线知道存储的是内存中的哪一块内容）
- 数据在cache中的状态（例如是否有效，是否改写等）

# cache设计需要考虑的问题



## cache块映射/索引的方式

cache的内存容量远小于内存容量，会涉及到多个内存单元映射到同一个cache单元；通常有如下3中映射方式:
`将内存和 Cache 都分为大小一样的块, 假设内存有 32 项, Cache 有 8 项 `

### 直接相连

每个内存块只能映射到cache的固定位置

> 在直接相联方式中, 每个内存块只能放到 Cache 的一个位置上, 假设要把内存的第 12 号块放
> 到 Cache 中, 因为 Cache 只有 8 项, 所以只能放在第 (12 mod 8 = 4) 项上, 其他地方都不能
> 放; 由此可知第 4、 12、 20、 28 号内存块都对应到 Cache 的第 4 项上, 如果冲突了就只能替换。
> 这就是直接相联, **硬件简单但利用率低**, 如图 9. 24a 所示。  

### 全相连

每个内存块可以映射到cache的任意位置

>在全相联方式中, 每个内存块都可以放到 Cache 的任一位置上, 这样第 4、 12、 20、 28 号内存块可以同时放入 Cache 中。 这就是全
>相联, **硬件复杂但利用率高**, 如图 9. 24b 所示  

### 组相连

每个内存块可以映射都任意组的固定位置

>组相联是直接相联和全相联的折中。 以两路组相
>联为例, Cache 中第 0、 2、 4、 6 号位置为一路 (这里称为第 0 路), 第 1、 3、 5、 7 为另一路
>(这里称为第 1 路), 每路 4 个 Cache 块。 对于内存的第 12 号块, 因为 12 除以 4 余数为 0, 所
>以既可以把第 12 号块放到 Cache 第 0 路的第 0 号位置 (即 Cache 的第 0 号位置), 也可以放到
>第 1 路的第 0 号位置 (即 Cache 的第 1 号位置), 如图 9. 24c 所示  

{% asset_img cache映射原理图.png %}

<center><u>cache映射原理图</u></center>

## 不同映射方式对应的cache结构

访问 Cache 时地址可分为 3 个部分: 偏移 (Offset)、 索引 (Index) 和标签 ( Tag)。   

- Offset 是块内地址, 在地址的低位。 因为 Cache 块一般比较大, 通常包含 32 字节或 64 字节, 而指令或数据访问往往没有
  这么宽, 需要通过 Offset 来指定访问对象在块内的具体位置。 
- Index 是用来索引 Cache 块的, 将其作为地址来访问 Cache。 
- 地址剩余的高位部分是访问 Cache 的 Tag, 用于和 Cache 中保存的 Tag 进行比较, 如果相等就给出命中信号 Hit。   

{% asset_img 不同映射方式对应的cache结构.png %}
<center><u>不同映射方式对应的cache结构</u></center>


>在直接相联结构中, 访问地址的 Tag 仅需要和 Index 索引的那个 Cache 块的 Tag 比较; 
>
>在全相联结构中, Index 位数为 0, 访问地址的 Tag 需要和每个
>Cache 块的 Tag 比较, 如果相等就给出命中信号 Hit, 同时将命中项的 Cache 块的 Data 通过 Mux
>(多路选择器, Multiplexer) 选出; 
>
>在组相联结构中, 访问地址的 Tag 需要和每一组中 Index 索
>引的那个 Cache 块的 Tag 比较, 生成 Hit 信号并选出命中项的 Data。 

`注意 Offset 位数只和 Cache块大小相关, 但 Tag 和 Index 位数则和相联度相关`。 
例如在 32 位处理器中, 如果 Cache 大小为16KB, 块大小为 32 字节, 则 Offset 为 5 位, 共有 512 个 Cache 块。 采用直接相联结构 Index 为9 位, Tag 为 18 位; 采用全相联结构 Index 为 0 位, Tag 为 27 位; 采用两路组相联结构 Index 为8 位, Tag 为 19 位。  



## cache的读写策略

### cache读策略

cache的都策略比较简单。如果读命中，则直接访问cache中的内容；如果读未命中，则会进行读分配

### cache写策略

{% asset_img cache的写策略.png %}

<center><u>cache的写策略</u></center>

思考一个问题：`为什么写直达要搭配写不分配，写回要搭配写分配？`

>采用写不分配的结果就是，永远不会将数据加载到cache中。
>
>写分配的结果就是，会将数据加载到cache中。
>
>**如果写回+写不分配会出现什么什么情况？**
>
>初始情况下，cache中的数据都是invalid的。现在考虑对同一个地址进行写操作，那么写回+写不分配这种方式，永远都是不会命中，一直在操作内存。不如写回+写分配，第一次不命中之后，数据会加载到cache中，之后就会写命中，就会访问cache，效率更高
>
>**如果写直达+写分配会出现什么情况？**
>
>初始情况下，cache中的数据都是invalid的。现在考虑对同一个地址进行写操作，那么写直达+写分配这种方式，第一次未命中之后，数据会加载到cache，但是之后即使命中，仍然会一直访问内存，效率不会变高没实际意义，而且需要额外写cache（因为未命中的时候，先将数据搬运到cache，因为未下写成功，接下来还会发生一次写，此时命中，会直接写到内存）。不如直接写直达+写不分配，这样直接写内存就可以，避免写分配需要额外写一次cache！

## cache的替换策略

当 发 生Cache 失效而需要取回想要的 Cache 行,此时如果 Cache 满了, 则需要进行替换。
进行 Cache 替换时, 如果有多个 Cache 行可供替换, 可以选择`随机进行替换`, 也可以`替换掉最先进入 Cache 的 Cache 行(FIFO 替换)`, 或者`替换掉最近最少使用
的 Cache 行 (LRU 替换)`。  

---

参考书籍&博客：

1. 《计算机体系结构基础》第3版.胡伟武

2. [Cache的基础知识](https://zhuanlan.zhihu.com/p/632189718)
3. [计算机组成原理-Cache写策略](https://blog.csdn.net/qq_41587740/article/details/109104962)
4. [关于Cache写直达搭配写不分配，写回搭配写分配的理解](https://blog.csdn.net/m0_47088143/article/details/125826983)
